<script>
    // A regular equality check == has a problem. It cannot differentiate 0 from false:
    alert( 0 == false ); // true

    // The same thing happens with an empty string:
    alert( '' == false ); //true

    /* This happens because operands of different types are converted to numbers by the equality operator ==. An empty string, just like false, becomes a zero.

    What to do if we’d like to differentiate 0 from false?

    A strict equality operator === checks the equality without type conversion.

    In other words, if a and b are of different types, then a === b immediately returns false without an attempt to convert them.

    Let’s try it: */

    alert( 0 === false ); // false, because the types are different

    // Comparison with null and undefined

  /*   There’s a non-intuitive behavior when null or undefined are compared to other values.

    For a strict equality check ===
    These values are different, because each of them is a different type. */

    alert( null === undefined ); //false

    // for a non-strinc check ==
    //There’s a special rule. These two are a “sweet couple”: they equal each other (in the sense of ==), but not any other value.

    alert( null == undefined ); // true

    /*     For maths and other comparisons < > <= >=
    null/undefined are converted to numbers: null becomes 0, while undefined becomes NaN.

    Now let’s see some funny things that happen when we apply these rules. And, what’s more important, how to not fall into a trap with them. */


</script>